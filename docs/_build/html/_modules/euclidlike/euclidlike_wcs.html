

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>euclidlike.euclidlike_wcs &mdash; GalSim-Euclid-Like 0.9.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=39bb1c6d"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GalSim-Euclid-Like
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../euclidlike.html">The Euclid-like Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../euclidlike_imsim.html">The Euclid-like ImSim Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim-Euclid-Like</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">euclidlike.euclidlike_wcs</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for euclidlike.euclidlike_wcs</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">@file euclidlike_wcs.py</span>

<span class="sd">This file includes any routines needed to define and use the Euclid-like WCS.</span>
<span class="sd">Current version is based on the focal plane description detailed in </span>
<span class="sd">Scaramella et al. (Fig. 2 and Table 1).</span>
<span class="sd">The distortion coefficients were derived from the ERO release.</span>

<span class="sd">Scaramella et al.: https://arxiv.org/abs/2108.01201</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">coord</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="kn">from</span> <span class="nn">importlib.resources</span> <span class="kn">import</span> <span class="n">files</span>

<span class="kn">from</span> <span class="nn">galsim</span> <span class="kn">import</span> <span class="n">GSFitsWCS</span><span class="p">,</span> <span class="n">FitsHeader</span>
<span class="kn">from</span> <span class="nn">galsim</span> <span class="kn">import</span> <span class="n">PositionD</span>
<span class="kn">from</span> <span class="nn">galsim</span> <span class="kn">import</span> <span class="n">BoundsI</span>
<span class="kn">from</span> <span class="nn">galsim</span> <span class="kn">import</span> <span class="n">GalSimRangeError</span><span class="p">,</span> <span class="n">GalSimError</span>

<span class="kn">from</span> <span class="nn">.instrument_params</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">pixel_scale_mm</span><span class="p">,</span>
    <span class="n">plate_scale</span><span class="p">,</span>
    <span class="n">n_ccd</span><span class="p">,</span>
    <span class="n">n_ccd_row</span><span class="p">,</span>
    <span class="n">n_ccd_col</span><span class="p">,</span>
    <span class="n">n_pix_row</span><span class="p">,</span>
    <span class="n">n_pix_col</span><span class="p">,</span>
    <span class="n">det2ccd</span><span class="p">,</span>
    <span class="n">ccd2det</span><span class="p">,</span>
    <span class="n">min_sun_angle</span><span class="p">,</span>
    <span class="n">max_sun_angle</span><span class="p">,</span>
<span class="p">)</span>


<span class="c1"># Basic Euclid reference info.</span>
<span class="n">n_pv</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Number of PV coefficients used, where arrays are n_pv x 2 in dimension</span>

<span class="c1"># Version-related information. At the moment the version are based on Scaramella et al. 2021</span>
<span class="n">tel_name</span> <span class="o">=</span> <span class="s2">&quot;Euclid&quot;</span>
<span class="n">instr_name</span> <span class="o">=</span> <span class="s2">&quot;VIS&quot;</span>
<span class="n">optics_design_ver</span> <span class="o">=</span> <span class="s2">&quot;S21&quot;</span>

<span class="c1"># Information about center points of the CCDs in the VIS focal plane coordinate system</span>
<span class="c1"># coordinates.</span>
<span class="c1"># Units are mm.</span>
<span class="n">infile</span> <span class="o">=</span> <span class="n">files</span><span class="p">(</span><span class="s1">&#39;euclidlike.data&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;ccd_data.dat&#39;</span><span class="p">)</span>
<span class="n">ccd_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span>
    <span class="n">infile</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;CCD_ID&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;U3&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;xc&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;yc&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;uc&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;vc&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>
<span class="n">ccd_xc_mm</span> <span class="o">=</span> <span class="n">ccd_data</span><span class="p">[</span><span class="s2">&quot;xc&quot;</span><span class="p">]</span>
<span class="n">ccd_yc_mm</span> <span class="o">=</span> <span class="n">ccd_data</span><span class="p">[</span><span class="s2">&quot;yc&quot;</span><span class="p">]</span>
<span class="n">ccd_crval_u_deg</span> <span class="o">=</span> <span class="n">ccd_data</span><span class="p">[</span><span class="s2">&quot;uc&quot;</span><span class="p">]</span>
<span class="n">ccd_crval_v_deg</span> <span class="o">=</span> <span class="n">ccd_data</span><span class="p">[</span><span class="s2">&quot;vc&quot;</span><span class="p">]</span>
<span class="c1"># Nominal center of FPA from the payload axis in this coordinate system, in mm and as an angle</span>
<span class="c1"># (neglecting distortions - to be included later).</span>
<span class="n">fpa_xc_mm</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">fpa_yc_mm</span> <span class="o">=</span> <span class="mf">0.859</span><span class="o">/</span><span class="n">plate_scale</span>
<span class="n">xc_fpa</span> <span class="o">=</span> <span class="mf">0.</span><span class="o">*</span><span class="n">coord</span><span class="o">.</span><span class="n">radians</span>
<span class="n">yc_fpa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">0.859</span><span class="p">)</span><span class="o">*</span><span class="n">coord</span><span class="o">.</span><span class="n">radians</span>

<span class="c1"># Gaps between CCDs</span>
<span class="n">x_gap_as</span> <span class="o">=</span> <span class="mf">12.7</span>
<span class="n">y_gap_as</span> <span class="o">=</span> <span class="mf">64.4</span>
<span class="n">x_gap_mm</span> <span class="o">=</span> <span class="n">x_gap_as</span><span class="o">/</span><span class="n">plate_scale</span>
<span class="n">y_gap_mm</span> <span class="o">=</span> <span class="n">y_gap_as</span><span class="o">/</span><span class="n">plate_scale</span>

<span class="c1"># The next array contains rotation offsets of individual CCD Y axis relative to FPA.</span>
<span class="n">ccd_rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ccd_xc_mm</span><span class="p">)</span>

<span class="c1"># Rotation of WFI local axes relative to payload axes: this is expressed as a CCW rotation</span>
<span class="c1"># relative to observatory +Z direction.</span>
<span class="n">theta_fpa</span> <span class="o">=</span> <span class="mf">0.</span><span class="o">*</span><span class="n">coord</span><span class="o">.</span><span class="n">degrees</span>

<span class="c1"># File with PV coefficients.</span>
<span class="n">pv_filename</span> <span class="o">=</span> <span class="n">files</span><span class="p">(</span><span class="s1">&#39;euclidlike.data&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;pv_coeffs.dat&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="getWCS">
<a class="viewcode-back" href="../../euclidlike.html#euclidlike.getWCS">[docs]</a>
<span class="k">def</span> <span class="nf">getWCS</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">PA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">CCDs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PA_is_FPA</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">SAA</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine returns a dict containing a WCS for each of the Euclid CCDs.</span>
<span class="sd">    The Euclid CCDs are labeled 0-35, so these numbers are used as the keys in</span>
<span class="sd">    the dict.  Alternatively the user can request a subset of the CCDs using</span>
<span class="sd">    the ``CCDs`` option.  The basic instrument parameters used to create the</span>
<span class="sd">    WCS correspond to those in Early Release Observations (ERO) data and are </span>
<span class="sd">    likely to change in the future.</span>

<span class="sd">    The user must specify a position for observation, at which the center of</span>
<span class="sd">    the focal plane array will point. This must be supplied as a CelestialCoord</span>
<span class="sd">    ``world_pos``.  In general, only certain positions are observable on</span>
<span class="sd">    certain dates, and for a given position there is an optimal position angle</span>
<span class="sd">    for the observatory (with the solar panels pointed as directly towards the</span>
<span class="sd">    sun as possible).  Users who are knowledgable about these details may</span>
<span class="sd">    choose to supply a position angle as ``PA``, either for the observatory or</span>
<span class="sd">    for the focal plane (using ``PA_is_FPA`` to indicate this).  But otherwise,</span>
<span class="sd">    the routine will simply choose the optimal position angle for a given date.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        world_pos:      A `galsim.CelestialCoord` indicating the position to</span>
<span class="sd">                        observe at the center of the focal plane array (FPA).</span>
<span class="sd">                        Note that if the given position is not observable on</span>
<span class="sd">                        the given date, then the routine will raise an</span>
<span class="sd">                        exception.</span>
<span class="sd">        PA:             A `galsim.Angle` representing the position angle of the</span>
<span class="sd">                        observatory +Y axis, unless ``PA_is_FPA=True``, in</span>
<span class="sd">                        which case it&#39;s the position angle of the FPA.  For</span>
<span class="sd">                        users to do not care about this, then leaving this as</span>
<span class="sd">                        None will result in the routine using the supplied</span>
<span class="sd">                        ``date`` and ``world_pos`` to select the optimal</span>
<span class="sd">                        orientation for the observatory.  Note that if a user</span>
<span class="sd">                        supplies a ``PA`` value, the routine does not check</span>
<span class="sd">                        whether this orientation is actually allowed.</span>
<span class="sd">                        [default: None]</span>
<span class="sd">        date:           The date of the observation, as a python datetime</span>
<span class="sd">                        object.  If None, then the vernal equinox in 2025 will</span>
<span class="sd">                        be used.  [default: None]</span>
<span class="sd">        PA_is_FPA:      If True, then the position angle that was provided was</span>
<span class="sd">                        the PA of the focal plane array, not the observatory.</span>
<span class="sd">                        [default: False]</span>
<span class="sd">        CCDs:           A single number or iterable giving the CCDs for which</span>
<span class="sd">                        the WCS should be obtained.  If None, then the WCS is</span>
<span class="sd">                        calculated for all CCDs. [default: None]</span>
<span class="sd">        SAA:            A `galsim.Angle` representing the Solar Aspect Angle</span>
<span class="sd">                        of the telescope for the observation. If not provided,</span>
<span class="sd">                        it will be computed internally.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dict of WCS objects for each CCD.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First just parse the input quantities.</span>
    <span class="n">date</span><span class="p">,</span> <span class="n">CCDs</span><span class="p">,</span> <span class="n">pa_fpa</span><span class="p">,</span> <span class="n">pa_obsy</span> <span class="o">=</span> <span class="n">_parse_WCS_inputs</span><span class="p">(</span>
        <span class="n">world_pos</span><span class="p">,</span> <span class="n">PA</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">PA_is_FPA</span><span class="p">,</span> <span class="n">CCDs</span><span class="p">,</span> <span class="n">SAA</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Note, this routine reads in the coeffs.  We don&#39;t use them until later, but read them in for</span>
    <span class="c1"># all CCDs at once.</span>
    <span class="n">PVs</span> <span class="o">=</span> <span class="n">_parse_pv_file</span><span class="p">(</span><span class="n">pv_filename</span><span class="p">)</span>

    <span class="c1"># Loop over CCDs:</span>
    <span class="n">wcs_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i_ccd</span> <span class="ow">in</span> <span class="n">CCDs</span><span class="p">:</span>
        <span class="c1"># Set up the header.</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Populate some necessary variables in the FITS header that are always the same, regardless of</span>
        <span class="c1"># input and CCD number.</span>
        <span class="n">_populate_required_fields</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

        <span class="c1"># And populate some things that just depend on the overall locations or other input, not on</span>
        <span class="c1"># the CCD.</span>
        <span class="n">header</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="p">(</span><span class="s2">&quot;RA&quot;</span><span class="p">,</span>  <span class="n">world_pos</span><span class="o">.</span><span class="n">ra</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="s2">&quot;reconstructed pointing RA&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;DEC&quot;</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">dec</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="s2">&quot;reconstructed pointing DEC&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;PA&quot;</span><span class="p">,</span> <span class="n">pa_fpa</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="s2">&quot;reconstructed position angle&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;RA_COMM&#39;</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">ra</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="s2">&quot;commanding pointing RA&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;DEC_COMM&#39;</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">dec</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="s2">&quot;commanding pointing DEC&quot;</span><span class="p">),</span>
            <span class="c1"># (&#39;PA_OBSY&#39;, pa_obsy / coord.degrees, &quot;position angle of observatory Y axis (deg)&quot;),</span>
            <span class="p">(</span><span class="s1">&#39;PA_COMM&#39;</span><span class="p">,</span> <span class="n">pa_fpa</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="s2">&quot;commanding position angle&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;DETID&#39;</span><span class="p">,</span> <span class="n">i_ccd</span><span class="p">,</span> <span class="s2">&quot;CCD-ID field from science TM (0-35)&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;CCDID&#39;</span><span class="p">,</span> <span class="n">det2ccd</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">],</span> <span class="s2">&quot;e.g. Detector ID, e.g. &#39;0-0&#39;, &#39;1-1&#39; ... &#39;6-6&#39;&quot;</span><span class="p">),</span>
        <span class="p">])</span>

        <span class="c1"># Get position of CCD center given the center of the FPA and the</span>
        <span class="c1"># orientation angle of the focal plane.</span>
        <span class="n">crval</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_get_ccd_center_pos</span><span class="p">(</span><span class="n">i_ccd</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">pa_fpa</span><span class="p">)</span>

        <span class="c1"># Compute the position angle of the local pixel Y axis.</span>
        <span class="c1"># This requires projecting local North onto the detector axes.</span>
        <span class="c1"># Start by adding any CCD-unique rotation relative to FPA axes:s</span>
        <span class="n">sca_tp_rot</span> <span class="o">=</span> <span class="n">pa_fpa</span> <span class="o">+</span> <span class="n">ccd_rot</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span><span class="o">*</span><span class="n">coord</span><span class="o">.</span><span class="n">degrees</span>

        <span class="c1"># Go some reasonable distance from crval in the +y direction.  Say, 1 degree.</span>
        <span class="n">plus_y</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">deproject</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;gnomonic&#39;</span><span class="p">)</span>
        <span class="c1"># Find the angle between this point, crval and due north.</span>
        <span class="n">north</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">CelestialCoord</span><span class="p">(</span><span class="mf">0.</span><span class="o">*</span><span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="mf">90.</span><span class="o">*</span><span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span>
        <span class="n">pa_sca</span> <span class="o">=</span> <span class="n">sca_tp_rot</span> <span class="o">-</span> <span class="n">crval</span><span class="o">.</span><span class="n">angleBetween</span><span class="p">(</span><span class="n">plus_y</span><span class="p">,</span> <span class="n">north</span><span class="p">)</span>

        <span class="c1"># Rotate by pa_fpa.</span>
        <span class="n">cos_pa_sca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">pa_sca</span><span class="p">)</span>
        <span class="n">sin_pa_sca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">pa_sca</span><span class="p">)</span>

        <span class="n">header</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="p">(</span><span class="s1">&#39;CRVAL1&#39;</span><span class="p">,</span> <span class="n">crval</span><span class="o">.</span><span class="n">ra</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;CRVAL2&#39;</span><span class="p">,</span> <span class="n">crval</span><span class="o">.</span><span class="n">dec</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;CD1_1&#39;</span><span class="p">,</span> <span class="n">cos_pa_sca</span> <span class="o">*</span> <span class="n">PVs</span><span class="p">[</span><span class="s2">&quot;CD1_1&quot;</span><span class="p">][</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">-</span> <span class="n">sin_pa_sca</span> <span class="o">*</span> <span class="n">PVs</span><span class="p">[</span><span class="s2">&quot;CD1_2&quot;</span><span class="p">][</span><span class="n">i_ccd</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;CD1_2&#39;</span><span class="p">,</span> <span class="n">sin_pa_sca</span> <span class="o">*</span> <span class="n">PVs</span><span class="p">[</span><span class="s2">&quot;CD1_1&quot;</span><span class="p">][</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">+</span> <span class="n">cos_pa_sca</span> <span class="o">*</span> <span class="n">PVs</span><span class="p">[</span><span class="s2">&quot;CD1_2&quot;</span><span class="p">][</span><span class="n">i_ccd</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;CD2_1&#39;</span><span class="p">,</span> <span class="n">cos_pa_sca</span> <span class="o">*</span> <span class="n">PVs</span><span class="p">[</span><span class="s2">&quot;CD2_1&quot;</span><span class="p">][</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">-</span> <span class="n">sin_pa_sca</span> <span class="o">*</span> <span class="n">PVs</span><span class="p">[</span><span class="s2">&quot;CD2_2&quot;</span><span class="p">][</span><span class="n">i_ccd</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;CD2_2&#39;</span><span class="p">,</span> <span class="n">sin_pa_sca</span> <span class="o">*</span> <span class="n">PVs</span><span class="p">[</span><span class="s2">&quot;CD2_1&quot;</span><span class="p">][</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">+</span> <span class="n">cos_pa_sca</span> <span class="o">*</span> <span class="n">PVs</span><span class="p">[</span><span class="s2">&quot;CD2_2&quot;</span><span class="p">][</span><span class="n">i_ccd</span><span class="p">]),</span>
        <span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">PVs</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;PV&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">header</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">PVs</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i_ccd</span><span class="p">]))</span>

        <span class="n">header</span> <span class="o">=</span> <span class="n">FitsHeader</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="n">wcs</span> <span class="o">=</span> <span class="n">GSFitsWCS</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="c1"># Store the original header as an attribute of the WCS. This ensures that we have all the</span>
        <span class="c1"># extra keywords for whenever an image with this WCS is written to file.</span>
        <span class="n">wcs</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="n">wcs_dict</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">=</span> <span class="n">wcs</span>

    <span class="k">return</span> <span class="n">wcs_dict</span></div>



<span class="k">def</span> <span class="nf">convertCenter</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">CCD</span><span class="p">,</span> <span class="n">PA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">SAA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PA_is_FPA</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">coord</span><span class="o">.</span><span class="n">arcsec</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a simple helper routine that takes an input position ``world_pos`` that is meant to</span>
<span class="sd">    correspond to the position of the center of an CCD, and tells where the center of the focal</span>
<span class="sd">    plane array should be.  The goal is to provide a position that can be used as an input to</span>
<span class="sd">    getWCS(), which wants the center of the focal plane array.</span>

<span class="sd">    The results of the calculation are deterministic if given a fixed position angle (PA).  If it&#39;s</span>
<span class="sd">    not given one, it will try to determine the best one for this location and date, like getWCS()</span>
<span class="sd">    does.</span>

<span class="sd">    Because of distortions varying across the focal plane, this routine has to iteratively correct</span>
<span class="sd">    its initial result based on empirical tests.  The ``tol`` kwarg can be used to adjust how</span>
<span class="sd">    careful it will be, but it always does at least one iteration.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        world_pos:  A galsim.CelestialCoord indicating the position to observe at the center of the</span>
<span class="sd">                    given CCD.  Note that if the given position is not observable on</span>
<span class="sd">                    the given date, then the routine will raise an exception.</span>
<span class="sd">        CCD:        A single number giving the CCD for which the center should be located at</span>
<span class="sd">                    ``world_pos``.</span>
<span class="sd">        PA:         galsim.Angle representing the position angle of the observatory +Y axis, unless</span>
<span class="sd">                    ``PA_is_FPA=True``, in which case it&#39;s the position angle of the FPA.  For</span>
<span class="sd">                    users to do not care about this, then leaving this as None will result in the</span>
<span class="sd">                    routine using the supplied ``date`` and ``world_pos`` to select the optimal</span>
<span class="sd">                    orientation for the observatory.  Note that if a user supplies a ``PA`` value,</span>
<span class="sd">                    the routine does not check whether this orientation is actually allowed.</span>
<span class="sd">                    [default: None]</span>
<span class="sd">        SAA:        A `galsim.Angle` representing the Solar Aspect Angle</span>
<span class="sd">                    of the telescope for the observation. If not provided,</span>
<span class="sd">                    it will be computed internally.</span>
<span class="sd">        date:       The date of the observation, as a python datetime object.  If None, then the</span>
<span class="sd">                    vernal equinox in 2025 will be used.  [default: None]</span>
<span class="sd">        PA_is_FPA:  If True, then the position angle that was provided was the PA of the focal</span>
<span class="sd">                    plane array, not the observatory. [default: False]</span>
<span class="sd">        tol:        Tolerance for errors due to distortions, as a galsim.Angle.</span>
<span class="sd">                    [default: 0.5*galsim.arcsec]</span>

<span class="sd">    Returns:</span>
<span class="sd">        A CelestialCoord object indicating the center of the focal plane array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">CCD</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must pass in an int corresponding to the CCD&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tol</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">Angle</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;tol must be a galsim.Angle&quot;</span><span class="p">)</span>
    <span class="n">use_CCD</span> <span class="o">=</span> <span class="n">CCD</span>
    <span class="c1"># Parse inputs appropriately.</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">pa_fpa</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_parse_WCS_inputs</span><span class="p">(</span>
        <span class="n">world_pos</span><span class="p">,</span> <span class="n">PA</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">PA_is_FPA</span><span class="p">,</span> <span class="p">[</span><span class="n">CCD</span><span class="p">],</span> <span class="n">SAA</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Now pretend world_pos was the FPA center and we want to find the location of this CCD:</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_get_ccd_center_pos</span><span class="p">(</span><span class="n">use_CCD</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">pa_fpa</span><span class="p">)</span>
    <span class="c1"># The (u, v) values give an offset, and we can invert this.</span>
    <span class="n">fpa_cent</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">deproject</span><span class="p">(</span><span class="o">-</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;gnomonic&#39;</span><span class="p">)</span>
    <span class="c1"># This is only approximately correct, especially for detectors that are far from the center of</span>
    <span class="c1"># the FPA, because of distortions etc.  We can do an iterative correction.</span>
    <span class="c1"># For the default value of &#39;tol&#39;, typically just 1-2 iterations are needed.</span>
    <span class="n">shift_val</span> <span class="o">=</span> <span class="mf">1000.0</span>  <span class="c1"># arcsec</span>
    <span class="k">while</span> <span class="n">shift_val</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="o">/</span><span class="n">coord</span><span class="o">.</span><span class="n">arcsec</span><span class="p">:</span>
        <span class="n">test_wcs</span> <span class="o">=</span> <span class="n">getWCS</span><span class="p">(</span><span class="n">fpa_cent</span><span class="p">,</span> <span class="n">PA</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">use_CCD</span><span class="p">,</span> <span class="n">PA_is_FPA</span><span class="p">)[</span><span class="n">use_CCD</span><span class="p">]</span>
        <span class="n">im_cent_pos</span> <span class="o">=</span> <span class="n">PositionD</span><span class="p">(</span><span class="n">n_pix_row</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_pix_col</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">test_sca_pos</span> <span class="o">=</span> <span class="n">test_wcs</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">im_cent_pos</span><span class="p">)</span>
        <span class="n">delta_ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">world_pos</span><span class="o">.</span><span class="n">dec</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">world_pos</span><span class="o">.</span><span class="n">ra</span><span class="o">-</span><span class="n">test_sca_pos</span><span class="o">.</span><span class="n">ra</span><span class="p">)</span>
        <span class="n">delta_dec</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">dec</span><span class="o">-</span><span class="n">test_sca_pos</span><span class="o">.</span><span class="n">dec</span>
        <span class="n">shift_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">world_pos</span><span class="o">.</span><span class="n">distanceTo</span><span class="p">(</span><span class="n">test_sca_pos</span><span class="p">)</span><span class="o">/</span><span class="n">coord</span><span class="o">.</span><span class="n">arcsec</span><span class="p">)</span>
        <span class="n">fpa_cent</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">CelestialCoord</span><span class="p">(</span><span class="n">fpa_cent</span><span class="o">.</span><span class="n">ra</span> <span class="o">+</span> <span class="n">delta_ra</span><span class="p">,</span> <span class="n">fpa_cent</span><span class="o">.</span><span class="n">dec</span> <span class="o">+</span> <span class="n">delta_dec</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fpa_cent</span>


<div class="viewcode-block" id="findCCD">
<a class="viewcode-back" href="../../euclidlike.html#euclidlike.findCCD">[docs]</a>
<span class="k">def</span> <span class="nf">findCCD</span><span class="p">(</span><span class="n">wcs_dict</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">include_border</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a subroutine to take a dict of WCS (one per CCD) from euclidlike.getWCS() and query</span>
<span class="sd">    which CCD a particular real-world coordinate would be located on.  The position (``world_pos``)</span>
<span class="sd">    should be specified as a galsim.CelestialCoord.  If the position is not located on any of the</span>
<span class="sd">    CCDs, the result will be None.  Note that if ``wcs_dict`` does not include all CCDs in it, then</span>
<span class="sd">    it&#39;s possible the position might lie on one of the CCDs that was not included.</span>

<span class="sd">    Depending on what the user wants to do with the results, they may wish to use the</span>
<span class="sd">    ``include_border`` keyword.  This keyword determines whether or not to include an additional</span>
<span class="sd">    border corresponding to half of the gaps between CCDs.  For example, if a user is drawing a</span>
<span class="sd">    single image they may wish to only know whether a given position falls onto a CCD, and if so,</span>
<span class="sd">    which one (ignoring everything in the gaps).  In contrast, a user who plans to make a sequence</span>
<span class="sd">    of dithered images might find it most useful to know whether the position is either on a CCD or</span>
<span class="sd">    close enough that in a small dither sequence it might appear on the CCD at some point.  Use of</span>
<span class="sd">    ``include_border`` switches between these scenarios.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        wcs_dict:        The dict of WCS&#39;s output from euclidlike.getWCS().</span>
<span class="sd">        world_pos:       A galsim.CelestialCoord indicating the sky position of interest.</span>
<span class="sd">        include_border:  If True, then include the half-border around CCD to cover the gap</span>
<span class="sd">                         between each sensor. [default: False]</span>

<span class="sd">    Returns:</span>
<span class="sd">        an integer value of the CCD on which the position falls, or None if the position is not</span>
<span class="sd">        on any CCD.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Sanity check args.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wcs_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;wcs_dict should be a dict containing WCS output by euclidlike.getWCS.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">CelestialCoord</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Position on the sky must be given as a galsim.CelestialCoord.&quot;</span><span class="p">)</span>

    <span class="c1"># Set up the minimum and maximum pixel values, depending on whether or not to include the</span>
    <span class="c1"># border.  We put it immediately into a galsim.BoundsI(), since the routine returns xmin, xmax,</span>
    <span class="c1"># ymin, ymax:</span>
    <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">_calculate_minmax_pix</span><span class="p">(</span><span class="n">include_border</span><span class="p">)</span>
    <span class="n">bounds_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">BoundsI</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">ccd</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i_ccd</span> <span class="ow">in</span> <span class="n">wcs_dict</span><span class="p">:</span>
        <span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs_dict</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span>
        <span class="n">image_pos</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">world_pos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds_list</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span><span class="o">.</span><span class="n">includes</span><span class="p">(</span><span class="n">image_pos</span><span class="p">):</span>
            <span class="n">ccd</span> <span class="o">=</span> <span class="n">i_ccd</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">ccd</span></div>



<span class="k">def</span> <span class="nf">_calculate_minmax_pix</span><span class="p">(</span><span class="n">include_border</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a helper routine to calculate the minimum and maximum pixel values that should be</span>
<span class="sd">    considered within a CCD, possibly including the complexities of including 1/2 of the gap</span>
<span class="sd">    between CCDs. In that case it depends on the detailed geometry of the Euclid focal plane.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        include_border:     A boolean value that determines whether to include 1/2 of the gap</span>
<span class="sd">                            between CCDs as part of the CCD itself.  [default: False]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a tuple of NumPy arrays for the minimum x pixel value, maximum x pixel value, minimum y</span>
<span class="sd">        pixel value, and maximum y pixel value for each CCD.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First, set up the default (no border).</span>
    <span class="c1"># The minimum and maximum pixel values are (1, n_pix).</span>
    <span class="n">min_x_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_ccd</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">max_x_pix</span> <span class="o">=</span> <span class="n">min_x_pix</span> <span class="o">+</span> <span class="n">n_pix_col</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">min_y_pix</span> <span class="o">=</span> <span class="n">min_x_pix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">max_y_pix</span> <span class="o">=</span> <span class="n">min_y_pix</span> <span class="o">+</span> <span class="n">n_pix_row</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Then, calculate the half-gaps, grouping together CCDs whenever possible.</span>
    <span class="k">if</span> <span class="n">include_border</span><span class="p">:</span>
        <span class="c1"># The gaps are set following https://arxiv.org/abs/2108.01201 table 1</span>
        <span class="c1"># At the moment the ccd edges that are also at the edge of the focal</span>
        <span class="c1"># plane are handle separately. But, the border is like any other</span>
        <span class="c1"># border.</span>
        <span class="n">half_border_x_pix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x_gap_mm</span><span class="o">/</span><span class="n">pixel_scale_mm</span><span class="p">)</span>
        <span class="n">half_border_y_pix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">y_gap_mm</span><span class="o">/</span><span class="n">pixel_scale_mm</span><span class="p">)</span>
        <span class="n">val_x_edge</span> <span class="o">=</span> <span class="n">half_border_x_pix</span>
        <span class="n">val_y_edge</span> <span class="o">=</span> <span class="n">half_border_y_pix</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_ccd_row</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_ccd_col</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">i_ccd</span> <span class="o">=</span> <span class="n">ccd2det</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">min_x_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">-=</span> <span class="n">val_x_edge</span>
                    <span class="n">max_x_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">+=</span> <span class="n">half_border_x_pix</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                    <span class="n">min_x_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">-=</span> <span class="n">half_border_x_pix</span>
                    <span class="n">max_x_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val_x_edge</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">min_x_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">-=</span> <span class="n">half_border_x_pix</span>
                    <span class="n">max_x_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">+=</span> <span class="n">half_border_x_pix</span>

                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">min_y_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">-=</span> <span class="n">half_border_y_pix</span>
                    <span class="n">max_y_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val_y_edge</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                    <span class="n">min_y_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">-=</span> <span class="n">val_y_edge</span>
                    <span class="n">max_y_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">+=</span> <span class="n">half_border_y_pix</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">min_y_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">-=</span> <span class="n">half_border_y_pix</span>
                    <span class="n">max_y_pix</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">+=</span> <span class="n">half_border_y_pix</span>

    <span class="k">return</span> <span class="n">min_x_pix</span><span class="p">,</span> <span class="n">max_x_pix</span><span class="p">,</span> <span class="n">min_y_pix</span><span class="p">,</span> <span class="n">max_y_pix</span>


<span class="k">def</span> <span class="nf">_populate_required_fields</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility routine to do populate some of the basic fields for the WCS headers for Euclid that</span>
<span class="sd">    don&#39;t require any interesting calculation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">header</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
        <span class="p">(</span><span class="s1">&#39;EQUINOX&#39;</span><span class="p">,</span> <span class="mf">2000.0</span><span class="p">,</span> <span class="s2">&quot;equinox of celestial coordinate system&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;WCSAXES&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;number of World Coordinate System axes&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;WCSNAME&#39;</span><span class="p">,</span> <span class="s1">&#39;viswcs_&#39;</span><span class="o">+</span><span class="n">optics_design_ver</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;CRPIX1&#39;</span><span class="p">,</span> <span class="n">n_pix_row</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;x-coordinate of reference pixel&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;CRPIX2&#39;</span><span class="p">,</span> <span class="n">n_pix_col</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;y-coordinate of reference pixel&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;CTYPE1&#39;</span><span class="p">,</span> <span class="s2">&quot;RA---TPV&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;CTYPE2&#39;</span><span class="p">,</span> <span class="s2">&quot;DEC--TPV&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;SIMPLE&#39;</span><span class="p">,</span> <span class="s1">&#39;True&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;BITPIX&#39;</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>  <span class="c1"># NOTE: BITPIX=8 in the real Euclid headers</span>
        <span class="p">(</span><span class="s1">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;EXTEND&#39;</span><span class="p">,</span> <span class="s1">&#39;True&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;BZERO&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;BSCALE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;TELESCOP&#39;</span><span class="p">,</span> <span class="n">tel_name</span><span class="p">,</span> <span class="s2">&quot;telescope used to acquire data&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;INSTRUME&#39;</span><span class="p">,</span> <span class="n">instr_name</span><span class="p">,</span> <span class="s2">&quot;identifier for instrument used to acquire data&quot;</span><span class="p">),</span>
    <span class="p">])</span>


<span class="k">def</span> <span class="nf">_parse_pv_file</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility routine to parse the file with the CD and PV coefficients and hand back an array to be used</span>
<span class="sd">    for later calculations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot find file that should have Euclid PVs coefficients: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">file</span>
        <span class="p">)</span>

    <span class="c1"># Parse the file, generated by make_sip_file.py in devel/roman directory.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">39</span><span class="p">))</span>

    <span class="n">PVs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="n">n_ccd</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="p">[</span>
            <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CD</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">+</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PV</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_pv</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i_ccd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ccd</span><span class="p">):</span>
            <span class="n">PVs</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;CD</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">i_ccd</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">n_pv</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i_ccd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ccd</span><span class="p">):</span>
            <span class="n">PVs</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;PV</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">i_ccd</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">PVs</span>


<span class="k">def</span> <span class="nf">_get_ccd_center_pos</span><span class="p">(</span><span class="n">i_ccd</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">pa_fpa</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This helper routine calculates the center position for a given CCD ``ccd`` given the position of</span>
<span class="sd">    the center of the focal plane array ``world_pos`` and an orientation angle for the observation.</span>
<span class="sd">    It is used by getWCS() and other routines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Go from the tangent plane position of the CCD center, to the actual celestial coordinate,</span>
    <span class="c1"># using `world_pos` as the center point of the tangent plane projection.  This celestial</span>
    <span class="c1"># coordinate for the CCD center is `crval`, which goes into the WCS as CRVAL1, CRVAL2.</span>
    <span class="n">cos_pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">pa_fpa</span><span class="p">)</span>
    <span class="n">sin_pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">pa_fpa</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">ccd_crval_v_deg</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">*</span> <span class="n">cos_pa</span> <span class="o">-</span> <span class="n">ccd_crval_u_deg</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin_pa</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">ccd_crval_v_deg</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin_pa</span> <span class="o">+</span> <span class="n">ccd_crval_u_deg</span><span class="p">[</span><span class="n">i_ccd</span><span class="p">]</span> <span class="o">*</span> <span class="n">cos_pa</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="n">coord</span><span class="o">.</span><span class="n">degrees</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">coord</span><span class="o">.</span><span class="n">degrees</span>
    <span class="n">crval</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">deproject</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;gnomonic&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">crval</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span>


<span class="k">def</span> <span class="nf">_parse_CCDs</span><span class="p">(</span><span class="n">CCDs</span><span class="p">):</span>
    <span class="c1"># This is a helper routine to parse the input CCDs (single number or iterable) and put it into a</span>
    <span class="c1"># convenient format.  It is used in roman_wcs.py.</span>
    <span class="c1">#</span>
    <span class="c1"># Check which CCDs are to be done.  Default is all (and they are 0-indexed).</span>
    <span class="n">all_CCDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_ccd</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Later we will use the list of selected CCDs to decide which ones we&#39;re actually going to do</span>
    <span class="c1"># the calculations for.  For now, just check for invalid numbers.</span>
    <span class="k">if</span> <span class="n">CCDs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Make sure CCDs is iterable.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">CCDs</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="n">CCDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">CCDs</span><span class="p">]</span>
        <span class="c1"># Then check for reasonable values.</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">CCDs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">CCDs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_ccd</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Invalid CCD.&quot;</span><span class="p">,</span> <span class="n">CCDs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_ccd</span><span class="p">)</span>
        <span class="c1"># Check for uniqueness.  If not unique, make it unique.</span>
        <span class="n">CCDs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">CCDs</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">CCDs</span> <span class="o">=</span> <span class="n">all_CCDs</span>
    <span class="k">return</span> <span class="n">CCDs</span>


<span class="k">def</span> <span class="nf">_parse_WCS_inputs</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">PA</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">PA_is_FPA</span><span class="p">,</span> <span class="n">CCDs</span><span class="p">,</span> <span class="n">SAA</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine parses the various input options to getWCS() and returns what the routine needs to</span>
<span class="sd">    do its job.  The reason to pull this out is so other helper routines can use it.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Parse input position</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">CelestialCoord</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Position on the sky must be given as a galsim.CelestialCoord!&quot;</span><span class="p">)</span>

    <span class="c1"># Get the date. (Vernal equinox in 2025, taken from</span>
    <span class="c1"># http://www.astropixels.com/ephemeris/soleq2001.html, if none was supplied.)</span>
    <span class="k">if</span> <span class="n">date</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Are we allowed to look here?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">allowedPos</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">SAA</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Error, Euclid cannot look at this position on this date!&quot;</span><span class="p">)</span>

    <span class="c1"># If position angle was not given, then get the optimal one:</span>
    <span class="k">if</span> <span class="n">PA</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">PA_is_FPA</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">PA</span> <span class="o">=</span> <span class="n">bestPA</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">SAA</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Just enforce type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">PA</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">Angle</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Position angle must be a galsim.Angle!&quot;</span><span class="p">)</span>

    <span class="c1"># Check which CCDs are to be done using a helper routine in the euclidlike module.</span>
    <span class="n">CCDs</span> <span class="o">=</span> <span class="n">_parse_CCDs</span><span class="p">(</span><span class="n">CCDs</span><span class="p">)</span>

    <span class="c1"># Compute position angle of FPA f2 axis, where positive corresponds to the angle east of North.</span>
    <span class="k">if</span> <span class="n">PA_is_FPA</span><span class="p">:</span>
        <span class="n">pa_fpa</span> <span class="o">=</span> <span class="n">PA</span>
        <span class="n">pa_obsy</span> <span class="o">=</span> <span class="n">PA</span> <span class="o">-</span> <span class="n">theta_fpa</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pa_obsy</span> <span class="o">=</span> <span class="n">PA</span>
        <span class="n">pa_fpa</span> <span class="o">=</span> <span class="n">PA</span> <span class="o">+</span> <span class="n">theta_fpa</span>

    <span class="k">return</span> <span class="n">date</span><span class="p">,</span> <span class="n">CCDs</span><span class="p">,</span> <span class="n">pa_fpa</span><span class="p">,</span> <span class="n">pa_obsy</span>


<span class="k">def</span> <span class="nf">allowedPos</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">SAA</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine can be used to check whether Euclid would be allowed to look at a particular</span>
<span class="sd">    position (``world_pos``) on a given ``date``.   This is determined by the angle of this position</span>
<span class="sd">    relative to the Sun.</span>

<span class="sd">    In general, Euclid can point at angles relative to the Sun in the range 90+20 &amp; 90-3 degrees.</span>
<span class="sd">    Obviously, pointing too close to the Sun would result in overly high sky backgrounds.  It is</span>
<span class="sd">    less obvious why Euclid cannot look at a spot directly opposite from the Sun (180 degrees on the</span>
<span class="sd">    sky).  The reason is that the observatory is aligned such that if the observer is looking at</span>
<span class="sd">    some sky position, the solar panels are oriented at 90 degrees from that position.  So it&#39;s</span>
<span class="sd">    always optimal for the observatory to be pointing at an angle of 90 degrees relative to the</span>
<span class="sd">    Sun.  It is also permitted to look within [-3, + 20] degrees of that optimal position.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        world_pos:      A galsim.CelestialCoord indicating the position at which the observer</span>
<span class="sd">                        wishes to look.</span>
<span class="sd">        date:           A python datetime object indicating the desired date of observation.</span>
<span class="sd">        SAA:            A `galsim.Angle` representing the Solar Aspect Angle</span>
<span class="sd">                        of the telescope for the observation. If not provided,</span>
<span class="sd">                        it will be computed internally.</span>

<span class="sd">    Returns:</span>
<span class="sd">        True or False, indicating whether it is permitted to look at this position on this date.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the Sun&#39;s location on the sky on this date.</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">sun_position_ecliptic</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
    <span class="n">sun</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">CelestialCoord</span><span class="o">.</span><span class="n">from_ecliptic</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">coord</span><span class="o">.</span><span class="n">radians</span><span class="p">,</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>

    <span class="c1"># Find the angle between that and the supplied position</span>
    <span class="k">if</span> <span class="n">SAA</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">angle_deg</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">world_pos</span><span class="o">.</span><span class="n">distanceTo</span><span class="p">(</span><span class="n">sun</span><span class="p">)</span><span class="o">/</span><span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">angle_deg</span> <span class="o">=</span> <span class="n">SAA</span><span class="o">/</span><span class="n">coord</span><span class="o">.</span><span class="n">degrees</span>

    <span class="c1"># Check if it&#39;s within tolerance.</span>
    <span class="n">min_ang</span> <span class="o">=</span> <span class="mf">90.</span> <span class="o">-</span> <span class="n">min_sun_angle</span><span class="o">/</span><span class="n">coord</span><span class="o">.</span><span class="n">degrees</span>
    <span class="n">max_ang</span> <span class="o">=</span> <span class="mf">90.</span> <span class="o">+</span> <span class="n">max_sun_angle</span><span class="o">/</span><span class="n">coord</span><span class="o">.</span><span class="n">degrees</span>
    <span class="k">return</span> <span class="n">min_ang</span> <span class="o">&lt;=</span> <span class="n">angle_deg</span> <span class="o">&lt;=</span> <span class="n">max_ang</span>


<span class="k">def</span> <span class="nf">bestPA</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">SAA</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine determines the best position angle for the observatory for a given observation date</span>
<span class="sd">    and position on the sky.</span>

<span class="sd">    The best/optimal position angle is determined by the fact that the solar panels are at 90</span>
<span class="sd">    degrees to the position being observed, and it is best to have those facing the Sun as directly</span>
<span class="sd">    as possible.  Note that if a given ``world_pos`` is not actually observable on the given</span>
<span class="sd">    ``date``, then this routine will return None.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        world_pos:      A galsim.CelestialCoord indicating the position at which the observer</span>
<span class="sd">                        wishes to look.</span>
<span class="sd">        date:           A python datetime object indicating the desired date of observation.</span>
<span class="sd">        SAA:            A `galsim.Angle` representing the Solar Aspect Angle</span>
<span class="sd">                        of the telescope for the observation. If not provided,</span>
<span class="sd">                        it will be computed internally.</span>

<span class="sd">    Returns:</span>
<span class="sd">        the best position angle for the observatory, as a galsim.Angle, or None if the position</span>
<span class="sd">        is not observable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First check for observability.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">allowedPos</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">SAA</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Find the location of the sun on this date.  +X_observatory points out into the sky, towards</span>
    <span class="c1"># world_pos, while +Z is in the plane of the sky pointing towards the sun as much as possible.</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">sun_position_ecliptic</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
    <span class="n">sun</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">CelestialCoord</span><span class="o">.</span><span class="n">from_ecliptic</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">coord</span><span class="o">.</span><span class="n">radians</span><span class="p">,</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
    <span class="c1"># Now we do a projection onto the sky centered at world_pos to find the (u, v) for the Sun.</span>
    <span class="n">sun_tp_x</span><span class="p">,</span> <span class="n">sun_tp_y</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">sun</span><span class="p">,</span> <span class="s1">&#39;gnomonic&#39;</span><span class="p">)</span>

    <span class="c1"># We want to rotate around by 90 degrees to find the +Y obs direction.  Specifically, we want</span>
    <span class="c1"># (+X, +Y, +Z)_obs to form a right-handed coordinate system.</span>
    <span class="n">y_obs_tp_x</span><span class="p">,</span> <span class="n">y_obs_tp_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">sun_tp_y</span><span class="p">,</span> <span class="n">sun_tp_x</span>
    <span class="n">y_obs</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">deproject</span><span class="p">(</span><span class="n">y_obs_tp_x</span><span class="p">,</span> <span class="n">y_obs_tp_y</span><span class="p">,</span> <span class="s1">&#39;gnomonic&#39;</span><span class="p">)</span>

    <span class="c1"># Finally the observatory position angle is defined by the angle between +Y_observatory and the</span>
    <span class="c1"># celestial north pole.  It is defined as position angle east of north.</span>
    <span class="n">north</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">CelestialCoord</span><span class="p">(</span><span class="n">y_obs</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span> <span class="mf">90.</span><span class="o">*</span><span class="n">coord</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span>
    <span class="n">obs_pa</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">angleBetween</span><span class="p">(</span><span class="n">y_obs</span><span class="p">,</span> <span class="n">north</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obs_pa</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Rachel Mandelbaum, Axel Guinot, Federico Berlfein, Andy Park, Xiangchong Li, Michael Troxel, Tianqing Zhang.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>