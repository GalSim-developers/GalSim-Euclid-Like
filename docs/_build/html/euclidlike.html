<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>euclidlike package &#8212; GalSim-Euclid-Like 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=d45e8c67"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="euclidlike-package">
<h1>euclidlike package<a class="headerlink" href="#euclidlike-package" title="Link to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
</section>
<section id="module-euclidlike.backgrounds">
<span id="euclidlike-backgrounds-module"></span><h2>euclidlike.backgrounds module<a class="headerlink" href="#module-euclidlike.backgrounds" title="Link to this heading">¶</a></h2>
<p>This file includes any routines needed to define the background level, for which the main contribution (currently the only one implemented) is zodiacal light.</p>
<dl class="py function">
<dt class="sig sig-object py" id="euclidlike.backgrounds.getSkyLevel">
<span class="sig-prename descclassname"><span class="pre">euclidlike.backgrounds.</span></span><span class="sig-name descname"><span class="pre">getSkyLevel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bandpass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">world_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exptime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2025</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/euclidlike/backgrounds.html#getSkyLevel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#euclidlike.backgrounds.getSkyLevel" title="Link to this definition">¶</a></dt>
<dd><p>Get the expected sky level for a Euclid observation due to zodiacal light for this bandpass
and position.</p>
<p>This routine can take an arbitray galsim.Bandpass() and calculate the zodiacal background
directly.  This is approximately 3x slower than using lookup tables.</p>
<p>The numbers that are returned are in units of e-/arcsec^2.  The result can either be multiplied
by the approximate pixel area to get e-/pix, or the result can be used with wcs.makeSkyImage()
to make an image of the sky that properly includes the actual pixel area as a function of
position on the detector.</p>
<p>Note that in general results will depend on the adopted model for zodiacal light, and these are
uncertain at the ~10% level.</p>
<p>Positions should be specified with the <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> keyword, which must be a CelestialCoord
object.  If no <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> is supplied, then the routine will use a default position that
looks sensibly away from the sun.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bandpass</strong> – A Bandpass object.</p></li>
<li><p><strong>world_pos</strong> – A position, given as a CelestialCoord object.  If None, then the routine
will use an ecliptic longitude of 90 degrees with respect to the sun
position (as a fair compromise between 0 and 180), and an ecliptic latitude
of 30 degrees with respect to the sun position (decently out of the plane
of the Earth-sun orbit). [default: None]</p></li>
<li><p><strong>exptime</strong> – Exposure time in seconds.  If None, use the longer Euclid exposure time.
[default: None]</p></li>
<li><p><strong>epoch</strong> – The epoch to be used for estimating the obliquity of the ecliptic when
converting <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> to ecliptic coordinates.  This keyword is only used
if <code class="docutils literal notranslate"><span class="pre">date</span></code> is None, otherwise <code class="docutils literal notranslate"><span class="pre">date</span></code> is used to determine the <code class="docutils literal notranslate"><span class="pre">epoch</span></code>.
[default: 2025]</p></li>
<li><p><strong>date</strong> – The date of the observation, provided as a python datetime object.  If None,
then the conversion to ecliptic coordinates assumes the sun is at ecliptic
coordinates of (0,0), as it is at the vernal equinox. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the expected sky level in e-/arcsec^2.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="euclidlike.backgrounds.getZodiBackground">
<span class="sig-prename descclassname"><span class="pre">euclidlike.backgrounds.</span></span><span class="sig-name descname"><span class="pre">getZodiBackground</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ecl_lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ecl_dlon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tlambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/euclidlike/backgrounds.html#getZodiBackground"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#euclidlike.backgrounds.getZodiBackground" title="Link to this definition">¶</a></dt>
<dd><p>This helper routine is used with permission from Chris Hirata’s Exposure Time Calculator and enables the
calculation of the zodiacal light in photons/m^2/arcsec^2/sec. The ETC may be found here:</p>
<p><a class="reference external" href="http://www.tapir.caltech.edu/~chirata/web/software/space-etc/">http://www.tapir.caltech.edu/~chirata/web/software/space-etc/</a></p>
<p>The code was ported from C to python by Michael Troxel (matroxel on GitHub).  The units are
exactly as in the original C code, and we convert to any other needed units outside of this
routine, in user-facing code.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ecl_lat</strong> – Ecliptic latitude (degrees)</p></li>
<li><p><strong>ecl_dlon</strong> – Ecliptic longitude (degrees)</p></li>
<li><p><strong>lambda_min</strong> – Minimum wavelength for the bandpass (microns)</p></li>
<li><p><strong>lambda_max</strong> – Maximum wavelength for the bandpass (microns)</p></li>
<li><p><strong>Tlambda</strong> – Numpy array containing a grid of wavelength values for the bandpass (microns)</p></li>
<li><p><strong>T</strong> – Numpy array containing the throughput (normalized to be between 0-1) for the
bandpass</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A floating point value for the zodiacal light in photons/m^2/arcsec^2/sec</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-euclidlike.bandpass">
<span id="euclidlike-bandpass-module"></span><h2>euclidlike.bandpass module<a class="headerlink" href="#module-euclidlike.bandpass" title="Link to this heading">¶</a></h2>
<p>&#64;file bandpass.py</p>
<p>This file includes any routines needed to define the Euclid bandpasses.
This module is heavily based on the roman bandpass.py file from the GalSim package.
<a class="reference external" href="https://github.com/GalSim-developers/GalSim/blob/releases/2.5/galsim/roman/roman_bandpass.py">https://github.com/GalSim-developers/GalSim/blob/releases/2.5/galsim/roman/roman_bandpass.py</a></p>
<p>The Euclid VIS bandpass is read in from the Euclid_VIS.vis.dat file which can be downloaded from
<a class="reference external" href="http://svo2.cab.inta-csic.es/svo/theory/fps3/index.php?mode=browse&amp;gname=Euclid&amp;gname2=VIS&amp;asttype=">http://svo2.cab.inta-csic.es/svo/theory/fps3/index.php?mode=browse&amp;gname=Euclid&amp;gname2=VIS&amp;asttype=</a>.</p>
<p>The Euclid NISP bandpasses are read in from files downloaded from
<a class="reference external" href="https://euclid.esac.esa.int/msp/refdata/nisp/NISP-PHOTO-PASSBANDS-V1">https://euclid.esac.esa.int/msp/refdata/nisp/NISP-PHOTO-PASSBANDS-V1</a></p>
<dl class="py function">
<dt class="sig sig-object py" id="euclidlike.bandpass.getBandpasses">
<span class="sig-prename descclassname"><span class="pre">euclidlike.bandpass.</span></span><span class="sig-name descname"><span class="pre">getBandpasses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AB_zeropoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_thin_trunc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_bandpass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/euclidlike/bandpass.html#getBandpasses"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#euclidlike.bandpass.getBandpasses" title="Link to this definition">¶</a></dt>
<dd><p>Function to get the bandpass information for the Euclid VIS band and the three Euclid NISP passbands.</p>
<p>This routine reads in files containing a list of wavelengths and
transmission values for the Euclid bands. The files are located in the
euclidlike.data directory. The routine then creates a Bandpass object
using the LookupTable class from the GalSim package, and returns a dict with bandpasses for the
keys.</p>
<p>The bandpasses are publicly available from IPAC:
<a class="reference external" href="http://svo2.cab.inta-csic.es/svo/theory/fps3/index.php?mode=browse&amp;gname=Euclid&amp;gname2=VIS&amp;asttype=">http://svo2.cab.inta-csic.es/svo/theory/fps3/index.php?mode=browse&amp;gname=Euclid&amp;gname2=VIS&amp;asttype=</a>.
<a class="reference external" href="https://euclid.esac.esa.int/msp/refdata/nisp/NISP-PHOTO-PASSBANDS-V1">https://euclid.esac.esa.int/msp/refdata/nisp/NISP-PHOTO-PASSBANDS-V1</a></p>
<p>These are relatively old files that do not include the latest estimates of system response.
They correspond to end-of-life estimates, with some expected degradation of the QE and filter
transmission over time.  This can lead to flux estimates that are suppressed by 5-10% from
beginning-of-life flux estimates.</p>
<p>The VIS bandpass red and blue limits are set not by the transmission curve but by the range of
wavelengths over which we have tabulated PSF images.  The wavelength range is read in from the
instrument parameter file.</p>
<p>Args:
AB_zeropoint (bool) : If True, set the zeropoint of the bandpass to the AB magnitude system. [default: True]
default_thin_trunc (bool) : If True, use the default thinning and truncation parameters. [default: True]
full_bandpass (bool): if True, use the full bandpass without red/blue limits needed for PSF</p>
<blockquote>
<div><p>calculations. [default: False]</p>
</div></blockquote>
<p>kwargs : Additional keyword arguments to pass to either <cite>Bandpass.thin</cite> or <cite>Bandpass.truncate</cite>.</p>
</dd></dl>

</section>
<section id="module-euclidlike.euclidlike_psf">
<span id="euclidlike-euclidlike-psf-module"></span><h2>euclidlike.euclidlike_psf module<a class="headerlink" href="#module-euclidlike.euclidlike_psf" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="euclidlike.euclidlike_psf.getBrightPSF">
<span class="sig-prename descclassname"><span class="pre">euclidlike.euclidlike_psf.</span></span><span class="sig-name descname"><span class="pre">getBrightPSF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ccd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandpass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ccd_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pupil_bin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wcs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_waves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gsparams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/euclidlike/euclidlike_psf.html#getBrightPSF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#euclidlike.euclidlike_psf.getBrightPSF" title="Link to this definition">¶</a></dt>
<dd><p>Get a fake optical PSF for very bright objects in Euclid-like simulations.
Depending on the inputs, this routine returns a chromatic or achromatic PSF using the
Euclid telescope diameter and Euclid-like aperture.</p>
<p>Args:
ccd (int):  Single value specifying the CCD for which the PSF should be</p>
<blockquote>
<div><p>loaded.</p>
</div></blockquote>
<dl class="simple">
<dt>bandpass (str): Single string specifying the bandpass to use when</dt><dd><p>defining the pupil plane configuration and/or interpolation of
chromatic PSFs.</p>
</dd>
<dt>ccd_pos:  Single galsim.PositionD indicating the position within the CCD</dt><dd><p>for which the PSF should be created. If None, the exact center of the
CCD is chosen. [default: None]</p>
</dd>
<dt>wcs:  The WCS to use to project the PSF into world coordinates. [default:</dt><dd><p>galsim.PixelScale(euclidlike.pixel_scale)]</p>
</dd>
<dt>n_waves (int): Number of wavelengths to use for setting up interpolation of the</dt><dd><p>chromatic PSF objects, which can lead to much faster image
rendering.  If None, then no interpolation is used. Note that
users who want to interpolate can always set up the interpolation
later on even if they do not do so when calling <cite>getPSF</cite>.
[default: None]</p>
</dd>
<dt>wavelength (float):  An option to get an achromatic PSF for a single</dt><dd><p>wavelength, for users who do not care about chromaticity of the PSF. If
None, then the fully chromatic PSF is returned as an
InterpolatedChromaticObject. Alternatively the user should supply
either (a) a wavelength in nanometers, and they will get an
InterpolatedImage object for that wavelength, or (b) a bandpass object,
in which case they will get an InterpolatedImage objects defined at the
effective wavelength of that bandpass. [default: None]</p>
</dd>
<dt>gsparams:  An optional GSParams argument.  See the docstring for GSParams</dt><dd><p>for details. [default: None]</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A single PSF object (either an InterpolatedChromaticObject or an
InterpolatedImage depending on the inputs).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="euclidlike.euclidlike_psf.getPSF">
<span class="sig-prename descclassname"><span class="pre">euclidlike.euclidlike_psf.</span></span><span class="sig-name descname"><span class="pre">getPSF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ccd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandpass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ccd_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wcs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gsparams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/euclidlike/euclidlike_psf.html#getPSF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#euclidlike.euclidlike_psf.getPSF" title="Link to this definition">¶</a></dt>
<dd><p>Get a single PSF for a Euclid-like simulation.</p>
<p>These PSFs are based on precomputed, oversampled (by 3x) PSF images on a grid in wavelength and
focal plane position.  These images were provided by Lance Miller and Chris Duncan.  They are
meant to provide an approximately correct description of the PSF size and shape without the
level of accuracy needed for precision tests of weak lensing shear inference.  The precomputed
images are combined in a way that accounts for the bandpass and (if provided) SED.  The effects
of detector linear charge diffusion, a simplified model for guiding errors, and wavefront error
due to measured surface figure errors are incorporated in the precomputed images.  The telescope
focus is set to a value from September 2023, and is therefore within a realistic range but does
not reflect variation over time for any particular observation.</p>
<p>Several important effects were omitted in these images, including the following:
* the effect of the dichroic;
* polarization aberrations;
* non-linear detector effects such as charge-transfer inefficiency, the brighter-fatter effect,</p>
<blockquote>
<div><p>and readout nonlinearity;</p>
</div></blockquote>
<ul class="simple">
<li><p>the effects of decontamination by ice.</p></li>
</ul>
<p>Functionally the lack of non-linear detector effects means the images produced should be thought
of as post-instrument signature removal (assuming the ISR process is carried out perfectly).</p>
<p>For applications that require very high accuracy in the modeling of the PSF, with very limited
aliasing, you may want to lower the <cite>folding_threshold</cite> in the gsparams.  Otherwise very bright
stars will show some reflections in the spider pattern and possibly some boxiness at the
outskirts of the PSF due to the size of the precomputed images.  Using <code class="docutils literal notranslate"><span class="pre">gsparams</span> <span class="pre">=</span>
<span class="pre">GSParams(folding_threshold=1.e-4)</span></code> generally provides good results.</p>
<p>The PSF model is constructed from oversampled images accross the focal plane.
Therefore, in order to use allow for a spatially varying PSF, the images must be downloaded
before using this function. This can be done using the terminal
command <cite>euclidlike_download_psf</cite>. The images are sampled at the 4 quadrant
centers of each CCD and at 17 discrete wavelengths. If the images are not
downloaded, the function will default to use the PSF from a default CCD quadrant, without any spatial variation.
The <cite>ccd</cite> argument refers to the detector ID (integer between 0-35),
not the focal plane position (in format column-row). The sampled
PSF images are stored using the focal plane position format. Therefore,
we convert the CCD detector ID to the appropiate focal plane position
internally.</p>
<p>In addition, the provided PSF images are normalized for obscuration,
vignetting and baffle effects. However, GalSim internally handles the
obscuration, so we remove this part of the normalization by dividing the
PSF images by collecting_area / ((diameter/2)**2*np.pi).  As a result, the sum of the pixel values in the renormalized PSF images is very close to 1.</p>
<p>Args:
ccd (int):  Single value specifying the CCD for which the PSF</p>
<blockquote>
<div><p>should be loaded.</p>
</div></blockquote>
<dl class="simple">
<dt>bandpass (str): Single string specifying the bandpass to use when</dt><dd><p>defining the pupil plane configuration and/or interpolation of
chromatic PSFs.</p>
</dd>
<dt>ccd_pos:  Single galsim.PositionD indicating the position within the CCD</dt><dd><p>for which the PSF should be created. If None, the exact center of the
CCD is chosen. [default: None]</p>
</dd>
<dt>wcs:  The WCS to use to project the PSF into world coordinates. [default:</dt><dd><p>galsim.PixelScale(euclid_like.roman.pixel_scale)]</p>
</dd>
<dt>wavelength (float):  An option to get an achromatic PSF for a single</dt><dd><p>wavelength, for users who do not care about chromaticity of the PSF. If
None, then the fully chromatic PSF is returned as an
InterpolatedChromaticObject. Alternatively the user should supply
either (a) a wavelength in nanometers, and they will get an
InterpolatedImage object for that wavelength, or (b) a bandpass object,
in which case they will get an InterpolatedImage objects defined at the
effective wavelength of that bandpass. [default: None]</p>
</dd>
<dt>gsparams:  An optional GSParams argument.  See the docstring for GSParams</dt><dd><p>for details. [default: None]</p>
</dd>
<dt>psf_dir (str): Directory where sampled PSF images can be accessed. If not</dt><dd><p>given, look in ./data directory. [default: None]</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A single PSF object (either an InterpolatedChromaticObject or an
InterpolatedImage depending on the inputs).</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-euclidlike.euclidlike_wcs">
<span id="euclidlike-euclidlike-wcs-module"></span><h2>euclidlike.euclidlike_wcs module<a class="headerlink" href="#module-euclidlike.euclidlike_wcs" title="Link to this heading">¶</a></h2>
<p>&#64;file euclidlike_wcs.py</p>
<p>This file includes any routines needed to define and use the Euclid-like WCS.
Current version is based on the focal plane description detailed in
Scaramella et al. (Fig. 2 and Table 1).
The distortion coefficients were derived from the ERO release.</p>
<p>Scaramella et al.: <a class="reference external" href="https://arxiv.org/abs/2108.01201">https://arxiv.org/abs/2108.01201</a></p>
<dl class="py function">
<dt class="sig sig-object py" id="euclidlike.euclidlike_wcs.allowedPos">
<span class="sig-prename descclassname"><span class="pre">euclidlike.euclidlike_wcs.</span></span><span class="sig-name descname"><span class="pre">allowedPos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">world_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/euclidlike/euclidlike_wcs.html#allowedPos"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#euclidlike.euclidlike_wcs.allowedPos" title="Link to this definition">¶</a></dt>
<dd><p>This routine can be used to check whether Euclid would be allowed to look at a particular
position (<code class="docutils literal notranslate"><span class="pre">world_pos</span></code>) on a given <code class="docutils literal notranslate"><span class="pre">date</span></code>.   This is determined by the angle of this position
relative to the Sun.</p>
<p>In general, Euclid can point at angles relative to the Sun in the range 90+20 &amp; 90-3 degrees.
Obviously, pointing too close to the Sun would result in overly high sky backgrounds.  It is
less obvious why Euclid cannot look at a spot directly opposite from the Sun (180 degrees on the
sky).  The reason is that the observatory is aligned such that if the observer is looking at
some sky position, the solar panels are oriented at 90 degrees from that position.  So it’s
always optimal for the observatory to be pointing at an angle of 90 degrees relative to the
Sun.  It is also permitted to look within [-3, + 20] degrees of that optimal position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>world_pos</strong> – A galsim.CelestialCoord indicating the position at which the observer
wishes to look.</p></li>
<li><p><strong>date</strong> – A python datetime object indicating the desired date of observation.</p></li>
<li><p><strong>SAA</strong> – A <cite>galsim.Angle</cite> representing the Solar Aspect Angle
of the telescope for the observation. If not provided,
it will be computed internally.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True or False, indicating whether it is permitted to look at this position on this date.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="euclidlike.euclidlike_wcs.bestPA">
<span class="sig-prename descclassname"><span class="pre">euclidlike.euclidlike_wcs.</span></span><span class="sig-name descname"><span class="pre">bestPA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">world_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/euclidlike/euclidlike_wcs.html#bestPA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#euclidlike.euclidlike_wcs.bestPA" title="Link to this definition">¶</a></dt>
<dd><p>This routine determines the best position angle for the observatory for a given observation date
and position on the sky.</p>
<p>The best/optimal position angle is determined by the fact that the solar panels are at 90
degrees to the position being observed, and it is best to have those facing the Sun as directly
as possible.  Note that if a given <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> is not actually observable on the given
<code class="docutils literal notranslate"><span class="pre">date</span></code>, then this routine will return None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>world_pos</strong> – A galsim.CelestialCoord indicating the position at which the observer
wishes to look.</p></li>
<li><p><strong>date</strong> – A python datetime object indicating the desired date of observation.</p></li>
<li><p><strong>SAA</strong> – A <cite>galsim.Angle</cite> representing the Solar Aspect Angle
of the telescope for the observation. If not provided,
it will be computed internally.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the best position angle for the observatory, as a galsim.Angle, or None if the position
is not observable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="euclidlike.euclidlike_wcs.convertCenter">
<span class="sig-prename descclassname"><span class="pre">euclidlike.euclidlike_wcs.</span></span><span class="sig-name descname"><span class="pre">convertCenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">world_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">CCD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PA_is_FPA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">coord.Angle(2.42406840554768e-06,</span> <span class="pre">coord.radians)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/euclidlike/euclidlike_wcs.html#convertCenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#euclidlike.euclidlike_wcs.convertCenter" title="Link to this definition">¶</a></dt>
<dd><p>This is a simple helper routine that takes an input position <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> that is meant to
correspond to the position of the center of an CCD, and tells where the center of the focal
plane array should be.  The goal is to provide a position that can be used as an input to
getWCS(), which wants the center of the focal plane array.</p>
<p>The results of the calculation are deterministic if given a fixed position angle (PA).  If it’s
not given one, it will try to determine the best one for this location and date, like getWCS()
does.</p>
<p>Because of distortions varying across the focal plane, this routine has to iteratively correct
its initial result based on empirical tests.  The <code class="docutils literal notranslate"><span class="pre">tol</span></code> kwarg can be used to adjust how
careful it will be, but it always does at least one iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>world_pos</strong> – A galsim.CelestialCoord indicating the position to observe at the center of the
given CCD.  Note that if the given position is not observable on
the given date, then the routine will raise an exception.</p></li>
<li><p><strong>CCD</strong> – A single number giving the CCD for which the center should be located at
<code class="docutils literal notranslate"><span class="pre">world_pos</span></code>.</p></li>
<li><p><strong>PA</strong> – galsim.Angle representing the position angle of the observatory +Y axis, unless
<code class="docutils literal notranslate"><span class="pre">PA_is_FPA=True</span></code>, in which case it’s the position angle of the FPA.  For
users to do not care about this, then leaving this as None will result in the
routine using the supplied <code class="docutils literal notranslate"><span class="pre">date</span></code> and <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> to select the optimal
orientation for the observatory.  Note that if a user supplies a <code class="docutils literal notranslate"><span class="pre">PA</span></code> value,
the routine does not check whether this orientation is actually allowed.
[default: None]</p></li>
<li><p><strong>SAA</strong> – A <cite>galsim.Angle</cite> representing the Solar Aspect Angle
of the telescope for the observation. If not provided,
it will be computed internally.</p></li>
<li><p><strong>date</strong> – The date of the observation, as a python datetime object.  If None, then the
vernal equinox in 2025 will be used.  [default: None]</p></li>
<li><p><strong>PA_is_FPA</strong> – If True, then the position angle that was provided was the PA of the focal
plane array, not the observatory. [default: False]</p></li>
<li><p><strong>tol</strong> – Tolerance for errors due to distortions, as a galsim.Angle.
[default: 0.5*galsim.arcsec]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A CelestialCoord object indicating the center of the focal plane array.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="euclidlike.euclidlike_wcs.findCCD">
<span class="sig-prename descclassname"><span class="pre">euclidlike.euclidlike_wcs.</span></span><span class="sig-name descname"><span class="pre">findCCD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wcs_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">world_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_border</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/euclidlike/euclidlike_wcs.html#findCCD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#euclidlike.euclidlike_wcs.findCCD" title="Link to this definition">¶</a></dt>
<dd><p>This is a subroutine to take a dict of WCS (one per CCD) from euclidlike.getWCS() and query
which CCD a particular real-world coordinate would be located on.  The position (<code class="docutils literal notranslate"><span class="pre">world_pos</span></code>)
should be specified as a galsim.CelestialCoord.  If the position is not located on any of the
CCDs, the result will be None.  Note that if <code class="docutils literal notranslate"><span class="pre">wcs_dict</span></code> does not include all CCDs in it, then
it’s possible the position might lie on one of the CCDs that was not included.</p>
<p>Depending on what the user wants to do with the results, they may wish to use the
<code class="docutils literal notranslate"><span class="pre">include_border</span></code> keyword.  This keyword determines whether or not to include an additional
border corresponding to half of the gaps between CCDs.  For example, if a user is drawing a
single image they may wish to only know whether a given position falls onto a CCD, and if so,
which one (ignoring everything in the gaps).  In contrast, a user who plans to make a sequence
of dithered images might find it most useful to know whether the position is either on a CCD or
close enough that in a small dither sequence it might appear on the CCD at some point.  Use of
<code class="docutils literal notranslate"><span class="pre">include_border</span></code> switches between these scenarios.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wcs_dict</strong> – The dict of WCS’s output from euclidlike.getWCS().</p></li>
<li><p><strong>world_pos</strong> – A galsim.CelestialCoord indicating the sky position of interest.</p></li>
<li><p><strong>include_border</strong> – If True, then include the half-border around CCD to cover the gap
between each sensor. [default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an integer value of the CCD on which the position falls, or None if the position is not
on any CCD.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="euclidlike.euclidlike_wcs.getWCS">
<span class="sig-prename descclassname"><span class="pre">euclidlike.euclidlike_wcs.</span></span><span class="sig-name descname"><span class="pre">getWCS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">world_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">CCDs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PA_is_FPA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/euclidlike/euclidlike_wcs.html#getWCS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#euclidlike.euclidlike_wcs.getWCS" title="Link to this definition">¶</a></dt>
<dd><p>This routine returns a dict containing a WCS for each of the Euclid CCDs.
The Euclid CCDs are labeled 0-35, so these numbers are used as the keys in
the dict.  Alternatively the user can request a subset of the CCDs using
the <code class="docutils literal notranslate"><span class="pre">CCDs</span></code> option.  The basic instrument parameters used to create the
WCS correspond to those in Early Release Observations (ERO) data and are
likely to change in the future.</p>
<p>The user must specify a position for observation, at which the center of
the focal plane array will point. This must be supplied as a CelestialCoord
<code class="docutils literal notranslate"><span class="pre">world_pos</span></code>.  In general, only certain positions are observable on
certain dates, and for a given position there is an optimal position angle
for the observatory (with the solar panels pointed as directly towards the
sun as possible).  Users who are knowledgable about these details may
choose to supply a position angle as <code class="docutils literal notranslate"><span class="pre">PA</span></code>, either for the observatory or
for the focal plane (using <code class="docutils literal notranslate"><span class="pre">PA_is_FPA</span></code> to indicate this).  But otherwise,
the routine will simply choose the optimal position angle for a given date.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>world_pos</strong> – A <cite>galsim.CelestialCoord</cite> indicating the position to
observe at the center of the focal plane array (FPA).
Note that if the given position is not observable on
the given date, then the routine will raise an
exception.</p></li>
<li><p><strong>PA</strong> – A <cite>galsim.Angle</cite> representing the position angle of the
observatory +Y axis, unless <code class="docutils literal notranslate"><span class="pre">PA_is_FPA=True</span></code>, in
which case it’s the position angle of the FPA.  For
users to do not care about this, then leaving this as
None will result in the routine using the supplied
<code class="docutils literal notranslate"><span class="pre">date</span></code> and <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> to select the optimal
orientation for the observatory.  Note that if a user
supplies a <code class="docutils literal notranslate"><span class="pre">PA</span></code> value, the routine does not check
whether this orientation is actually allowed.
[default: None]</p></li>
<li><p><strong>date</strong> – The date of the observation, as a python datetime
object.  If None, then the vernal equinox in 2025 will
be used.  [default: None]</p></li>
<li><p><strong>PA_is_FPA</strong> – If True, then the position angle that was provided was
the PA of the focal plane array, not the observatory.
[default: False]</p></li>
<li><p><strong>CCDs</strong> – A single number or iterable giving the CCDs for which
the WCS should be obtained.  If None, then the WCS is
calculated for all CCDs. [default: None]</p></li>
<li><p><strong>SAA</strong> – A <cite>galsim.Angle</cite> representing the Solar Aspect Angle
of the telescope for the observation. If not provided,
it will be computed internally.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dict of WCS objects for each CCD.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-euclidlike.instrument_params">
<span id="euclidlike-instrument-params-module"></span><h2>euclidlike.instrument_params module<a class="headerlink" href="#module-euclidlike.instrument_params" title="Link to this heading">¶</a></h2>
<p>Basic information GalSim needs to produce Euclid-like simulations.</p>
<p>When editing this file, you should also modify the imports in __init__.py</p>
</section>
<section id="module-euclidlike">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-euclidlike" title="Link to this heading">¶</a></h2>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">GalSim-Euclid-Like</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Rachel Mandelbaum, Axel Guinot, Federico Berlfein, Andy Park, Xiangchong Li, Michael Troxel, Tianqing Zhang.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/euclidlike.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>